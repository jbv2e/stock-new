# 🏗️ 최종 구조: API / Broker / Rule / Strategy / Notification / Worker

아키텍처를 크게 6개의 레이어로 나눈다.

### **1) API Layer (Next.js + NestJS)**
### **2) Domain Layer (Symbol, Rule, Strategy, Portfolio 등)**
### **3) Broker Layer (증권사 추상화 + 어댑터)**
### **4) Notification Layer (알림 채널 추상화)**
### **5) Rule Engine (조건 기반 알림 엔진)**
### **6) Strategy Engine (향후 강화학습/지표/백테스트/실시간 전략 처리)**
### **7) Worker Layer (예약 작업, 실시간 스트림 관리)**

이제 이걸 실제 프로젝트 구조로 펼쳐볼게.

---

# 🏛️ **1. Monorepo 기반 전체 디렉토리 구조 (NX 아니면 Turborepo 추천)**


root/
├─ apps/
│  ├─ api/               # NestJS 서버
│  ├─ web/               # Next.js + Shadcn 프론트
│  ├─ mobile/            # (선택) React Native 또는 Capacitor
│
├─ packages/
│  ├─ broker-core/       # 증권사 공통 interface + domain
│  ├─ broker-kis/        # 한국투자증권 openapi 어댑터
│  ├─ broker-nh/
│  ├─ broker-kiwoom/
│
│  ├─ notification-core/ # 알림 공통 interface
│  ├─ notification-telegram/
│  ├─ notification-discord/
│  ├─ notification-fcm/
│  ├─ notification-email/
│
│  ├─ rule-engine/       # 가격조건/저항선/지지선/거래량 룰엔진
│  ├─ strategy-core/     # 전략 공통 interface (전략엔진)
│  ├─ strategy-basic/    # 단순 전략 (이동평균, RSI 등)
│  ├─ strategy-python/   # Python 전략 호출 (gRPC)
│  ├─ strategy-ml/       # ML, 딥러닝 전략 (옵션)
│
│  ├─ shared/            # DTO, 공통 타입, 유틸
│
├─ infra/
│  ├─ db/                # Prisma schema or TypeORM entity
│  ├─ config/
│
├─ scripts/              # 배포, 마이그레이션, cron, worker 실행 스크립트


# 🧱 **2. Strategy Engine을 위한 확장 가능한 Interface 설계**

전략 엔진은 크게 **세 종류**로 나뉜다:

1. **Indicator-based 전략**
    
    - 이동평균, MACD, RSI, 볼린저밴드 등
        
2. **Event-driven 전략**
    
    - “가격이 저항선 돌파 → 매수”
        
    - “거래량 급증 → 알림”
        
3. **ML / Python 기반 전략**
    
    - LSTM/GBM/XGBoost
        
    - 백테스트 엔진
        
    - 예측 기반 매매
        

이를 모두 수용하는 인터페이스 설계가 핵심이다.

---

## 📌 Strategy Interface

```
// strategy-core/strategy.interface.ts
export interface Strategy {
  getName(): string;           // 전략 이름
  init(params: any): void;     // 초기 설정값 (symbol, period 등)
  onTick(tick: Quote): Promise<StrategyResult>;  // 실시간 처리
  onCandle(candle: Candle): Promise<StrategyResult>; // 봉 단위 처리
}

```

## 📌 StrategyResult 예시

```
export interface StrategyResult {
  triggered: boolean;
  action?: 'buy' | 'sell' | 'alert';
  message?: string;
  price?: number;
}
```

# 🧠 **3. Strategy Engine (Core)**

Strategy Engine은 다음 역할을 한다:

- 룰 기반 엔진 + 전략 기반 엔진을 모두 실행
    
- 종목별로 전략을 attach
    
- 실시간 tick/candle 들어올 때 모든 전략에게 전달
    
- 전략이 발동하면 알림/주문으로 연결
```
			   ┌────────────
tick/quote --->│ Strategy A ├──┐
			   └────────────┘  │
							   │
		       ┌────────────┐  │  StrategyResult(action)
tick/quote --->│ Strategy B ├──┼────────────────→ Notification/Order
		       └────────────┘  │
							   │
		       ┌────────────┐  │
tick/quote --->│ Strategy C ├──┘
		       └────────────┘


```
StrategyEngine 코드 예시:
```
// strategy-core/strategy-engine.ts
export class StrategyEngine {
  constructor(
    private readonly strategies: Strategy[],
    private readonly notifier: NotificationService,
    private readonly broker: Broker,
  ) {}

  async onTick(tick: Quote) {
    for (const s of this.strategies) {
      const result = await s.onTick(tick);
      if (result.triggered) {
        if (result.action === 'alert') {
          await this.notifier.sendAll(result.message!);
        }
        if (result.action === 'buy') {
          await this.broker.placeOrder({ 
            symbol: tick.symbol,
            price: result.price,
            side: 'BUY',
          });
        }
      }
    }
  }
}

```


# 🧬 **4. Python 전략 엔진을 위한 gRPC 구성 (권장 구조)**

Python 전략을 추가할 계획이라면 gRPC가 가장 호환성과 성능이 좋다.

```
NestJS StrategyEngine
      │
      │ onTick
      ▼
gRPC Client  ←→  gRPC Python서버
                    │
                    ├─ ML 모델 / Tensorflow / PyTorch
                    ├─ 백테스트 엔진
                    └─ 데이터 분석

```

### Proxy Interface (NestJS → Python)
```
// strategy-python/python-strategy.adapter.ts
export class PythonStrategyAdapter implements Strategy {
  constructor(private grpcClient: PythonStrategyGrpc) {}

  getName() { return 'python-ml'; }

  async onTick(tick: Quote) {
    return await this.grpcClient.evaluateTick(tick);
  }
}

```

=> Python 서버는 모델 실행/백테스트/ML을 담당.  
=> Node/Nest는 API + 알림 + 주문 통합만 담당 → 역할이 나뉘므로 유지보수 최적화.

---

# 🔔 **5. Rule Engine과 Strategy Engine의 역할 분리**

### Rule Engine = If → Then

예:

- 가격 > 10,000원 → 알림
- 20일 이동평균 돌파 → 텔레그램 알림
    

### Strategy Engine = 의사결정 로직

예:

- (MA20 > MA60) & (RSI < 30) 이면 매수
- ML 모델이 0.8 확률로 상승 예측 → 매수
    
둘은 따로 설계해야 한다.

---

# ⏱️ **6. Worker Layer (실시간 스트림 + 스케줄러)**

### 실시간 Tick Worker

- 증권사 WebSocket 연결
- 들어오는 tick → RuleEngine, StrategyEngine으로 전달
    
### Candle Worker

- 분봉/일봉 생성
- StrategyEngine.onCandle() 호출
    

### Scheduler (NestJS Cron)

- 계좌 잔고/포트폴리오 업데이트
- 사용자 설정 기반 알림 체크
    

→ Worker는 NestJS `@Processor`, `@Cron`, 또는 BullMQ 작업자 형태로 구성하는 걸 추천.

---

# 📊 **7. 프론트 구조 (Next.js + Shadcn)**

### 기본 페이지

- 대시보드 (계좌/포트폴리오)
- 종목 관리
- 알림/룰 관리 UI
- 전략 설정 페이지
    - 전략 선택
    - 전략 파라미터 설정
- 시세 차트/실시간 표시
    
### 주요 특징

- 모든 설정은 NestJS로 저장 (DB)
- Next.js는 화면/UI만 담당
- 전략/룰 엔진은 백엔드에서 실행
    

---

# 🏆 **최종 정리 — “전략 엔진 포함” 완전체 아키텍처**

 ```
                      ┌───────────────┐
                      │   Next.js UI  │
                      └───────┬───────┘
                              │ HTTP/REST/WS
                    ┌─────────▼──────────┐
                    │     NestJS API      │
                    └─────────┬───────────┘
             ┌────────────────┘
             │         
 ┌───────────▼───────────┐
 │    Domain Layer        │ (Symbol, Rule, Strategy, Portfolio)
 └───────────┬───────────┘
             │
 ┌───────────▼───────────┐
 │      Rule Engine       │
 └───────────┬───────────┘
             │ tick/candle
 ┌───────────▼───────────┐
 │   Strategy Engine      │------┐
 └───────────┬───────────┘       │  StrategyResult
             │                   │
       tick/quote                │
             │                   ▼
     ┌───────▼──────┐     ┌───────────────┐
     │   Broker     │     │ Notification  │
     │(증권사 추상화)│     │   Service     │
     └───────┬──────┘     └──────┬────────┘
             │                    │
   ┌─────────▼───────┐      ┌────▼─────┐
   │   증권사 API     │      │ 텔레그램 │
   │ (KIS, NH, KB...) │      │ 디스코드 │
   └──────────────────┘      │ Email...│
                             └─────────┘


          ┌──────────┐
          │ Python ML│  <── gRPC ── StrategyEngine
          │ 전략엔진  │
          └──────────┘

 ```



---

# 👉 다음 단계

원하면 내가 아래 중에서 **바로 코드/폴더 템플릿** 만들어줄 수 있어:

1. **Monorepo 디렉토리 구조 + package.json + tsconfig**
2. **Broker 추상화 + 한국투자증권 어댑터 실제 코드**
3. **NotificationChannel + 텔레그램/디스코드 구현**
4. **Rule Engine 스켈레톤 코드**
5. **Strategy Engine + 기본 전략(MA cross) 구현**
6. **NestJS gRPC + Python 전략 서버 템플릿**
    

어떤 걸로 시작하고 싶어?

##### 나의 말:

구글등을 이용한 사용자별 인증과 설정 분리, 보안성을 추가

###### ChatGPT의 말:

좋아, 이제 시스템 전체에 **“사용자 인증 + 사용자별 설정 분리 + 증권사 API 키/토큰 보안 강화”** 를 넣어서 _서비스급 구조_로 만들어줄게.  
지금까지 만든 **멀티 증권사 + 알림 + 전략엔진** 구조에다가  
“사용자 인증 / 보안 / 권한 / 민감정보 분리 저장”을 포함하면  
진짜로 완성형 트레이딩 플랫폼 구조가 된다.

---

# 🎯 최종 목표

- 구글/애플/네이버/카카오 OAuth로 사용자 로그인
- 사용자별로:
    - 증권사 API 인증정보 관리
    - 전략 설정/룰 설정/알림 채널 설정 분리
        
- 서버는 민감 데이터(DB, 토큰 등)를 절대 노출하지 않음
- 브라우저/앱은 오직 NestJS API Backend만 호출
- 백엔드는 증권사 API 요청 시 사용자별 권한 검증
    

---

# 🧱 1. 인증(로그인): Google OAuth 2.0 기반 구조

### Next.js → NestJS → OAuth Provider

전체 흐름:

```
Next.js (프론트)
   │  (구글 OAuth 로그인 버튼)
   ▼
Google OAuth Consent Screen
   │
   ▼
Next.js Callback → NestJS /auth/google/callback
   │
   ▼
NestJS AuthService
   │  - 사용자 DB 존재? → JWT 발급
   │  - 없으면 사용자 생성 후 JWT 발급
   ▼
Next.js에게 쿠키/세션 전달

```

### NestJS Auth 모듈 구성

- `AuthController`
- `GoogleStrategy` (passport-google-oauth20)
- `AuthService`
- `UserService`
    

### 사용자는 DB에 다음 형태로 저장됨

```
User {
  id: string;
  email: string;
  name: string;
  picture: string;
  provider: 'google' | 'kakao' | ...
  providerId: string;
  createdAt;
  updatedAt;
}

```

여기까지는 표준적이고, 보안성 높음.

---

# 🔐 2. 사용자별 증권사 API 인증정보 저장 → 암호화된 저장 방식

## 핵심 원칙

### ❌ 절대 평문으로 Access Token / 계좌번호 저장하지 않는다

### ❌ 프론트에 API Secret을 절대 내려주지 않는다

### ❌ DB에도 암호화 없이 저장하지 않는다

### ✔ 서버(NestJS)는 민감정보를 AES256 등으로 암호화하여 저장

### ✔ 암호화 키는 **환경변수 + KMS(GCP, AWS) 또는 Vault**에 저장

### ✔ 사용자별로 증권사 설정 객체 분리

### ✔ 브로커 호출 시 “해당 사용자 권한이 맞는지” 항상 검증

---

# 🔏 3. 사용자별 증권사 설정 저장 구조 (Encrypted)

DB 테이블:

```
BrokerCredential {
  id
  userId
  brokerType                // "kis" | "nh" | "kb" ...
  encryptedApiKey           // AES256 암호화된 값
  encryptedApiSecret
  encryptedAccountNumber
  encryptedAccessToken
  accessTokenExpiresAt
  createdAt
  updatedAt
}

```

### NestJS 서비스에서 암호화/복호화

```
import * as crypto from 'crypto';

@Injectable()
export class CryptoService {
  private algorithm = "aes-256-gcm";
  private key = process.env.ENCRYPTION_KEY;  // 32 bytes

  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    const enc = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);
    const tag = cipher.getAuthTag();
    return iv.toString('hex') + ':' + tag.toString('hex') + ':' + enc.toString('hex');
  }

  decrypt(payload: string): string {
    const [ivHex, tagHex, dataHex] = payload.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    const tag = Buffer.from(tagHex, 'hex');
    const encryptedText = Buffer.from(dataHex, 'hex');

    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(tag);

    const dec = Buffer.concat([
      decipher.update(encryptedText),
      decipher.final(),
    ]);
    return dec.toString('utf8');
  }
}

```

→ 모든 민감 정보는 DB에 들어가기 전에 `encrypt()`  
→ 브로커 API 호출할 때만 `decrypt()` 사용

---

# 🧩 4. 사용자별 설정(User Settings) 완전 분리

각종 설정들을 모두 User 기준으로 분리한다.

### 1) 종목 관리
```
UserWatchList {
  id
  userId
  symbolId
  memo
}

```

### 2) 룰/알림 조건 관리

```
UserAlertRule {
  id
  userId
  symbolId
  ruleType      // PRICE_ABOVE, EMA_CROSS, RESISTANCE_BREAK 등
  params        // JSON
  channels      // ['telegram', 'sms']
  isActive
}

```
### 3) 전략 관리
```
UserStrategy {
  id
  userId
  strategyName     // 'mean_reversion', 'macd', 'rsi'
  params           // 전략 인자 JSON
  isActive
}

```
### 4) 알림 채널 추가
```
UserNotificationChannel {
  id
  userId
  type              // telegram, discord, email, push 등
  config            // chatId, webhookUrl 등
  isActive
}

```
---

# 🔐 5. Broker 호출 시 사용자 권한 검증 로직

브로커 호출은 절대로 이런 식으로 하면 안 되고:

```
broker.getBalance();

```

이렇게 해야 한다:
```
brokerService.getBalanceForUser(userId);

```

그리고 내부는 이렇게 구성:
```
const cred = await BrokerCredentialRepo.findByUser(userId);
if (!cred) throw new ForbiddenException('No broker credential');

const broker = this.getBroker(cred.brokerType);
const decryptedKey = cryptoService.decrypt(cred.encryptedApiKey);

return broker.getBalance({
  apiKey: decryptedKey,
  token: cryptoService.decrypt(cred.encryptedAccessToken),
  account: cryptoService.decrypt(cred.encryptedAccountNumber),
});

```
왜?

✔ 사용자별로 권한 분리  
✔ 토큰 만료 관리 가능  
✔ 접근 제어 계층이 보안적으로 안전

---

# 🧱 6. 전략 엔진도 사용자별로 안전하게 분리

전략 엔진은 사용자별로 독립 프로세스로 실행하지 않음.  
단, “전략을 적용하는 대상 종목과 파라미터”를 사용자별로 적용.
```
StrategyEngine
  ├─ User A 전략 리스트
  ├─ User B 전략 리스트
  ├─ User C 전략 리스트

```

사용자별 전략을 데이터베이스에서 로딩:
```
const strategies = userStrategyRepo
  .find({ userId })
  .map(strategyRecord => StrategyFactory.create(strategyRecord));

```

→ 전략은 **유저 자신의 계좌에만 주문/알림이 발동**  
→ 타 유저의 전략에는 접근 불가능

---

# 🔒 7. 민감정보 보호를 위한 추가 보안층

여기까지는 기본이고, 고급 보안 구조를 원한다면 아래까지 넣으면 완전 프로급 시스템 된다.

---

## ✔ (1) 민감정보를 **분리된 DB 테이블**에 저장

- 일반 설정(UserWatchList, UserStrategy)은 일반 DB
- 민감정보(BrokerCredential)는 별도 DB 또는 별도 schema
    

→ 침해 시 피해 줄임

---

## ✔ (2) 서버 측 Key Rotation 지원 (매우 중요)

- AES 암호화 키를 rotation (예: 90일)
- 이전 버전 암호화 데이터도 읽을 수 있도록
- rotation 시 토큰/키 재암호화
    

---

## ✔ (3) 사용자 설정/전략/알림 접근 시 RBAC 적용

NestJS `RolesGuard` 도입:
```
ROLE_USER
ROLE_ADMIN

```

---

## ✔ (4) 모든 민감 API 요청은 Audit Log 저장

- “유저 A가 계좌 조회 실행”
- “유저 A가 주문 요청”
    
→ 사고 대응 시 필수

---

## ✔ (5) 웹/앱 인증은 HttpOnly Secure Cookie 기반 세션

### 이유:

- 로컬스토리지 X → XSS로 탈취 가능
- HttpOnly 쿠키는 자바스크립트가 읽지 못함
- JWT를 쿠키로 전달해서 보안 강화
    

---

# 🏆 최종 아키텍처 요약 (Security Layer 포함)

      ```
         ┌─────────────────────────────┐
         │          Next.js App        │
         │     (OAuth 로그인 + UI)      │
         └──────────────┬──────────────┘
                        │
                        ▼
        ┌──────────────────────────────────┐
        │            NestJS API             │
        │   Auth / User / Broker / Rule     │
        └──────────────┬───────────────────┘
                        │
             User JWT(세션 쿠키)
                        │
           ┌────────────▼────────────┐
           │       Domain Layer       │
           │  User별 설정/전략/룰 분리│
           └────────────┬────────────┘
                        │
                        ▼
         ┌────────────────────────────────┐
         │   Broker Credential Store       │
         │ (민감정보 AES256 암호화 저장)   │
         └────────────────────────────────┘
                        │
         ┌──────────────▼─────────────┐
         │   Broker Adapter (KIS/NH)   │
         └──────────────┬─────────────┘
                        │ OAuth Token
                        ▼
          증권사 Open API 서버(KIS 등)

─────────────────────────────────────────────

                 알림 계층(보안적 분리)
─────────────────────────────────────────────

        Rule Engine     Strategy Engine
              │                │
              ├──────────┬────┘
                         ▼
             Notification Service
         (Telegram / Discord / Push / Email)


      ```
