# 🥇 **1단계 — 인증/사용자 관리 기반 구축 (필수)**

### **Google OAuth / JWT / 세션 관리 / 사용자 테이블 구축**

🚩 이유
- 이게 시스템의 근간
- 인증 없이는 사용자별 설정, 전략, 알림 등 아무것도 할 수 없음
- 나중에 붙이면 모든 API에 인증 로직 다시 바꿔야 함 → 비용 폭발
    

📌 구현 항목
- Google OAuth
- NestJS Auth Module
- JWT HttpOnly Cookie 기반 세션
- User 엔티티 + 사용자 기본 정보 저장
- AuthGuard / RolesGuard
    

✨ _이 단계만 완료하면 Next.js 화면에서 로그인 테스트가 가능해짐._

---

# 🥈 **2단계 — 민감정보 저장 구조 구축 (암호화/키관리)**

### **증권사 API 키, 계좌, 토큰 저장 암호화 설계**

🚩 이유
- 브로커 API 연동보다 암호화/보안이 먼저다
- 보안이 확보되지 않으면 투자 서비스는 사고 나기 쉽고
- 나중에 암호화를 끼워 넣는 건 거의 재난임
    
📌 구현 항목
- AES-256 암호화 서비스(CryptoService)
- Rotating Encryption Key 구조
- BrokerCredential 테이블 분리
- get/set 시 자동 암호화/복호화
    

✨ _이 단계 후 사용자별로 “증권사 연결 상태” UI 만들 수 있음._

---

# 🥉 **3단계 — Broker 추상화 (멀티 증권사 대비 필수)**

### **Broker Interface + KISAdapter 구현**

🚩 이유
- 전략/룰/알림은 “시세/주문”을 기반으로 동작
- 일단 KIS를 붙이고, 다른 증권사는 나중에 붙여도 되지만
- Interface → Adapter 구조를 먼저 만들어야 확장이 쉬움
    

📌 구현 항목

- Broker 인터페이스 (getQuote, placeOrder 등)
- KIS OpenAPI Adapter
- BrokerFacade (유저별 증권사 선택)
- Token refresh 자동화
    

✨ _이제 계좌조회/시세조회/주문까지 가능해짐._

---

# 🏅 **4단계 — Notification Layer (기본 알림 시스템)**

### **텔레그램/디스코드/WebPush 같은 알림 채널 구조**

🚩 이유
- 룰엔진/전략엔진에서는 반드시 알림을 쏘게 됨
- 알림 채널을 먼저 만들면 이후 로직이 훨씬 유연해짐
    
📌 구현 항목
- Notifier 인터페이스
- TelegramNotifier
- DiscordNotifier
- NotificationService (여러 채널 병렬 알림)
    

✨ _이제 ‘조건 만족 → 푸시알림’ 구조가 작동함._

---

# 🎖️ **5단계 — Rule Engine (저항선/가격/거래량 조건 알림)**

### **사용자가 설정한 조건을 체크해 알림 발생**

🚩 이유
- 브로커/알림이 준비됐으니
- 첫 번째 실전 기능은 Rule Engine이 가장 단순하고 직관적임
    
📌 구현 항목
- Rule 인터페이스
- PriceAboveRule, PriceBelowRule
- ResistanceBreakRule
- RuleEngine
- Symbol/Rule DB 구조
- RuleEvaluator Worker (cron + websocket)
    
✨ _이제 사용자 설정 기반 가격 알림이 완성됨._  
(여기까지 오면 MVP 서비스 가능)

---

# 🏆 **6단계 — Strategy Engine (확장형 전략 시스템)**

### **MA, RSI, MACD 등 계산 / Python 전략 엔진 연동**

🚩 이유
- Rule Engine보다 고급 기능
- 데이터/지표/ML/전략의 복잡도가 높음
- 구조가 잘 잡힌 상태에서 추가해야 안전함

📌 구현 항목
- Strategy 인터페이스
- StrategyEngine
- BasicStrategy(MA cross 등)
- PythonStrategyAdapter
- gRPC 연동 (Python ML 전략)
    
✨ _이제 “자동 매매” 수준의 전략 로직까지 확장 가능._

---

# 🥇🏆 **최종 추천 순서 정리 (숫자만)**

1. **Auth / User (Google OAuth, JWT, Guard)**
2. **Security / Encryption / Credential Store**
3. **Broker Abstraction + KIS Adapter**
4. **Notification System**
5. **Rule Engine**
6. **Strategy Engine ( + Python ML 연동 )**
    

이 순서가  
**시간 낭비가 가장 적고, 구조 변경 없이 끝까지 확장 가능한 진짜 베스트 플로우**야.  
프로젝트가 커지면 구조 무너지는 경우 많거든.  
이 순서대로 가면 나중에 10배 커져도 안정적이다.

-----


결론부터 말하면:

- **지금 구조(백엔드 NestJS, 프론트 NextJS+shadcn)** 기준으로  
    → **API 서버는 Node/NestJS**,  
    → **향후 전략엔진(백테스트/ML 등)은 Python 별도 서비스** 조합을 추천합니다.
    
- 구현 순서도 “**전체 구조 → 인증/보안 → 증권사/알림 추상화 → 전략엔진**” 순으로 가는 게 좋아요.
    
- “**B 전체 구조 → A 인증 → B 암호화 → D 코드**”라는 식의 생각은 방향은 맞는데, 실제로는 약간만 재정렬하는 걸 권장합니다.
    

아래에서 정리해볼게요.

---

## 1. 한국투자증권 Open API: Python vs Node 추천

### 1) 지금 프로젝트 기준 추천

- **백엔드는 NestJS(= Node/TypeScript)** 로 할 거니까,
    
    - **REST 래퍼, 인증 토큰 발급, 사용자별 계좌·설정 관리, 알림 트리거** 같은 “서비스/서버” 로직은  
        → **NestJS로 구현**하는 게 자연스럽습니다.
        
- 다만,
    
    - **복잡한 전략, 백테스트, 데이터 분석** 같은 부분은  
        → **Python 마이크로서비스** 로 빼두면 훨씬 편합니다.
        

즉:

> **초기 버전**:
> 
> - 한국투자 API 호출: NestJS (Node/TS)
>     
> - 전략엔진: 나중에 Python 별도 서비스로 추가할 수 있게 인터페이스만 설계
>     

이 조합이 현재 스택(Next+Nest+shadcn)에 가장 잘 녹습니다.

### 2) 왜 Node/NestJS를 우선으로?

1. **한 언어(타입스크립트)로 프론트·백 통일**
    
    - DTO, 타입, 공용 도메인 모델(종목, 알림조건 등)을 **공유 라이브러리**로 뽑기 좋음.
        
    - 프론트(NextJS)와 백(NestJS)이 같은 타입을 쓰니 실수 줄어듦.
        
2. **실시간 처리 & 웹 생태계 친화적**
    
    - KIS 실시간 시세/체결은 WebSocket 기반인데,  
        Node는 WebSocket, SSE, gRPC 게이트웨이 같은 부분에서 편함.
        
    - 브라우저 → 백엔드 → 증권사 WebSocket 라우팅도 자연스럽고요.
        
3. **KIS 쪽 Python 예제는 많지만, Node도 REST는 어차피 똑같음**
    
    - KIS 공식/비공식 자료는 Python 예제가 제일 많습니다.[GitHub+1](https://github.com/Soju06/python-kis?utm_source=chatgpt.com)
        
    - 하지만 실제로는 **HTTP 호출+서명+토큰 관리**라,  
        NestJS에서 Axios/Fetch로 감싸면 크게 어렵지 않음.
        
4. **추후 다중 증권사 대응을 위한 “라이브러리화”가 용이**
    
    - `libs/brokers` 같은 TS 패키지로 추상화해 두면,  
        KIS/미래에셋/키움 등 증권사별 어댑터를 쉽게 추가 가능.
        

### 3) Python은 어디에 쓰면 좋나?

- **전략엔진 / 퀀트 연구 / 백테스트**, 예를 들면:
    
    - pandas, numpy, TA-Lib, scikit-learn 등
        
- 구조는 이렇게:
    
    - NestJS: 알림 조건/전략 정의·저장, 주문 실행, 사용자 관리
        
    - Python 서비스: 시세/과거 데이터 받아서 전략 평가 → “매수/매도/알림 이벤트” 메시지 발행
        
    - 두 서비스 간 통신: **Redis, RabbitMQ, Kafka, gRPC, HTTP** 등 선택
        

---

## 2. 전체 시스템 구조 (NestJS + NextJS 기준)

요구사항들을 레이어로 쪼개면:

### (1) Core 도메인/서비스 레이어

- **도메인 엔티티**
    
    - User, UserProfile
    - BrokerConnection (증권사별 API 키/토큰 + 설정)
    - Account, Position, Order
    - Symbol(종목), Watchlist
    - AlertRule (저항선/지지선/조건식 등)
    - Strategy, StrategyInstance (사용자별 전략 파라미터)
        
- **서비스 모듈 (NestJS)**
    
    - `AuthModule` : Google 등 OAuth2, JWT, 세션
    - `UserModule` : 유저/프로필/설정
    - `BrokerModule` : 증권사 통합 추상화
    - `AlertModule` : 알림 조건 저장/평가 스케줄링
    - `NotificationModule` : 텔레그램/디스코드/푸시 등
    - `StrategyModule` : 전략 정의/관리, (초기에는 심플한 조건엔진 → 나중에 Python 연동)
    - `AdminModule` : 전략/알림 템플릿, 공통 설정 등
        

---

### (2) 다중 증권사 API 추상화

목표: “타사 증권사 추가 시 최소 변경”

- 인터페이스 예시:
```
export interface BrokerClient {
  getBalance(userId: string): Promise<Balance>;
  getPositions(userId: string): Promise<Position[]>;
  getQuote(symbol: string): Promise<Quote>;
  placeOrder(userId: string, order: PlaceOrderRequest): Promise<OrderResult>;
  subscribeRealtime(symbols: string[], onTick: (tick: Tick) => void): UnsubscribeFn;
}

```

- 구현체 예:
    - `KisBrokerClient` (한국투자)
    - `KiwoomBrokerClient`
    - `LSBrokerClient`
- `BrokerFactory` / `BrokerRegistry` 로 증권사 식별자(`"KIS" | "KIWOOM" | ...`) 기반으로 구현체 반환.
    
> 이렇게 해두면 “타사 증권사 API를 호출할 필요가 있을 때”  
> **전략/알림/프론트 코드는 그대로** 두고,  
> **브로커 어댑터만 추가**하면 됩니다.
---

### (3) 알림 채널 추상화 (웹, 앱, 텔레그램, 디스코드 등)
- 인터페이스:
```
export interface Notifier {
  send(userId: string, message: NotificationPayload): Promise<void>;
}

```

- 구현체:
    - `WebPushNotifier`
    - `MobilePushNotifier` (FCM 등)
    - `TelegramNotifier`
    - `DiscordNotifier`
    - `EmailNotifier` (옵션)
        
- 사용자 설정:
    
    - `NotificationPreference` 엔티티에
        - 어떤 채널 사용/미사용
        - 채널별 토큰/챗ID
        - 주식/선물/특정 전략 등 필터링 조건
            

> 알림 채널을 이렇게 추상화해두면  
> “웹, 안드로이드 앱, 텔레그램, 디스코드 알림 추가”가  
> 단순히 **새 구현체 + 설정 화면만 추가**하는 수준이 됩니다.

---

### (4) 종목/알림 관리 구조

- NextJS + shadcn UI로 제공할 화면:
    - 종목 검색/추가/삭제
    - Watchlist 관리 (폴더/그룹)
    - 알림 조건 설정:
        - 가격 도달, 저항선/지지선 돌파
        - 거래량, 이동평균선, 조건식 등
    - 알림 채널/전략별 on/off
- 백엔드 로직:
    - `AlertRule`에:
        - target: symbol or strategy output
        - condition: DSL or JSON 조건
        - channel: one or many Notifiers
    - `AlertEvaluator`:
        - Cron/스케줄러 + 실시간 티커 스트림을 읽어서  
            조건 만족 시 → `NotificationModule` 호출
            

---

### (5) 추후 “전략 엔진” 추가를 염두에 둔 구조

지금은 간단한 조건(가격/거래량)만 쓰더라도,  
나중에 **“전략 엔진”** 을 붙이려면 경계선을 미리 만들어 두는 게 좋습니다.

- NestJS 쪽에서:
    - `StrategyDefinition` (전략 이름, 타입, 사용 언어, 버전 등)
    - `StrategyInstance` (사용자별 전략 + 파라미터)
    - `StrategyEngineGateway` (실제 계산은 외부 서비스/Python으로 위임)
        
- Python 전략엔진 서비스:
    
    - 시세/과거데이터 받아서, 특정 전략에 따라
        - “신호(Signal)” 또는 “알림 트리거” 이벤트를 발행 (예: Redis Pub/Sub, Kafka)
    - NestJS는 이 이벤트를 구독해서:
        - 주문 실행, 알림 전송
            

> 이렇게 해두면, 나중에 Python 전략엔진을 추가하더라도  
> **NestJS는 “전략엔진이 내게 신호를 준다”는 인터페이스만 알고**,  
> 내부 구현(Python/다른 언어)는 자유롭게 교체할 수 있습니다.

---

### (6) 구글 로그인 & 사용자별 설정/보안

- **Auth**
    - NestJS `AuthModule`에서:
        - Google OAuth2 (다른 SNS도 확장 가능)
        - JWT (Access/Refresh 토큰) 발급
            
    - User엔티티는 최소:
        - id, email, provider(Google 등), roles, status
            
- **보안/암호화**
    - 증권사 API Key, Secret, 계좌번호 등은:
        - DB에 평문 저장 금지
        - 최소한:
            - 서버측 암호화(KMS or libsodium/crypto 라이브러리) 후 저장
            - 복호화 키는 `.env`나 비밀 스토어에만
                
    - 로그에 **민감 정보 마스킹**
    - Rate limit, IP/지역 기반 추가 보안도 고려 가능
        
- **사용자별 설정 분리**
    - NotificationPreference, StrategyInstance, Watchlist 등은  
        항상 `userId` 스코프를 명확히.
        

---

## 3. 구현 “순서” 추천 & 제안하신 순서 피드백

질문:

> “B 전체 구조를 잡고, A 인증, B 암호화, D 코드로 가자. 어떰?”

방향은 맞는데, 조금 더 구체적으로 나누면 좋아요.  
제가 추천하는 순서는 이렇게입니다:

1. **아키텍처 / 도메인 모델 잡기 (B 전체 구조)**
    
    - 모노레포 구조 (예: pnpm workspace: `apps/api`, `apps/web`, `libs/domain`, `libs/brokers`, `libs/shared-types`)
    - 핵심 도메인 정의:
        - User, BrokerConnection, AlertRule, NotificationPreference, Strategy 등
    - NestJS 모듈 경계 (Auth, Broker, Alert, Notification, Strategy)만 먼저 설계
        
2. **인증 & 사용자 모델 (A 인증)**
    - Google OAuth2 로그인
    - JWT 발급/검증, User 생성/조회
    - “사용자별 설정 스코프”를 코드에 녹여두기
        
3. **보안/암호화 베이스라인 (B 암호화)**  
    (여기서 말한 ‘암호화/보안’ 단계)
    - KIS API 키/Secret 및 계좌번호 암호화 저장 로직
    - 환경변수/시크릿 관리 방식 확정
    - 로그/에러에 민감정보 노출 방지
    - 최소 권한 원칙(Role, 권한 설계 기초)
        
4. **증권사 통합 레이어 + KIS 어댑터 (D 코드 중 핵심 1)**
    - `BrokerClient` 인터페이스 정의
    - `KisBrokerClient` 구현
    - 시세 조회, 주문, 실시간 구독 등 최소 기능
    - 이때부터 실제 KIS Open API 연동 테스트
        
5. **알림/전략 기초 기능 (D 코드 확장)**
    - `AlertModule` (Rule CRUD + 스케줄러)
    - `NotificationModule` & Notifier 인터페이스 + 1~2개 채널(예: 텔레그램, 웹푸시)
    - NextJS + shadcn 기반 관리 UI (종목/알림/채널 설정)
        
6. **전략엔진용 인터페이스 정의 & Python PoC**
    - NestJS 쪽에 `StrategyEngineGateway` 정의
    - Python 서비스에서 단순 전략 하나 구현해 이벤트만 던져보는 PoC
    - 통신 경로(HTTP/Redis/Kafka 등) 검증
        
7. **고도화/리팩토링 & 추가 증권사, 채널, 전략**
    - Alert DSL, 복잡한 전략, 백테스트, 모니터링 등 확장
        

---

## 4. 요약 + 답변

- **언어 선택**
    
    - 지금 스택(NextJS + NestJS)을 기준으로 하면,
        - **백엔드(API 서버)는 NestJS(Node/TS)** 로 KIS Open API를 감싸는 걸 추천
        - **전략엔진/퀀트는 Python 별도 서비스**로 확장 가능하게 인터페이스만 미리 설계
            
- **구조**
    
    - “증권사 추상화 레이어 + 알림 채널 추상화 + 전략엔진 인터페이스” 이 세 개를 꼭 레이어로 나누기
    - 나중에 타 증권사/텔레그램/디스코드/모바일 앱/전략엔진을 추가할 때 **핵심 도메인/서비스는 그대로** 두고 구현체만 추가하는 구조로.
        
- **순서**
    
    - 제안하신 “구조 → 인증 → 암호화 → 코드” 큰 방향은 맞고,
    - 다만 “코드”도
        1. 브로커/알림/전략 등의 **핵심 도메인 서비스**
        2. 그 위에 NextJS+shadcn UI
        3. 마지막에 Python 전략엔진 PoC  
            이런 식으로 쪼개서 진행하면 리스크가 더 낮습니다.
            

원하시면,

- 실제 **모노레포 구조(pnpm workspace)** 예시,
- NestJS 모듈 구조,
- `BrokerClient`/`Notifier` 인터페이스 코드 샘플,
- NextJS+shadcn에서 종목/알림 관리 화면 기본 스켈레톤
    
